# NEOスマートコントラクト

## スマートコントラクトとは？

スマートコントラクトとは、契約者がこれらの契約をどのように実行するかについての合意を含む、デジタル形式で定義された一連の約束です。ブロックチェイン技術は、スマートコントラクトが非常に有用な分散型、改竄のない、信頼性の高いシステムを提供します。スマートコントラクトは、ブロックチェーンテクノロジの最も重要な特性の1つであり、ブロックチェーンを破壊的な技術と呼ぶ理由です。スマートコントラクトは社会構造の効率を日々高めています。

## NEOスマートコントラクトの特徴は何ですか？

NEO Smart Contract 2.0には、確実性、高性能、拡張性という機能が含まれています。契約タイプには、有効化契約、機能契約、およびアプリケーション契約があります。

パフォーマンスの観点から、NEOは、軽量のNeoVM（NEO仮想マシン）をスマートコントラクト実行環境として使用します。それは非常に速く起動し、少量のリソースを使い、短い手順のようなスマートコントラクトに適しています。ホットスポット契約の静的コンパイルとキャッシングは、JIT（リアルタイムコンパイラ）テクノロジによって大幅に強化できます。 NEO仮想マシンのインストラクションセットアップは、スマートコントラクトの暗号アルゴリズムの実行効率を最適化する一連の暗号命令を提供します。さらに、データ操作命令は、配列および複雑なデータ構造を直接サポートします。上記のすべてが、NEO Smart Contract 2.0のパフォーマンスを向上させます。

NEO Smart Contract 2.0は、高並列性と動的パーティショニングの組み合わせにより、低結合設計とスケーラブルなアプローチを実現します。低カップリング契約手順は、仮想マシン（NEO仮想マシン）で実行され、対話型サービスレイヤを介して外部と通信します。したがって、スマートコントラクト機能へのアップグレードの大部分は、インタラクティブサービスレイヤのAPIを通じて達成することができます。

## 任意の言語でスマートコントラクトを書く

言語の観点から見ると、NEO Smart Contract 2.0とEthereumの違いは、より直感的です。EthereumのSolinity言語とは異なり、NEOスマートコントラクトはほとんどの高水準プログラミング言語を直接使用できます。最初にサポートされる言語は、C＃、VB.Net、F＃、Java、およびKotlinです。 NEOは、これらの言語用のコンパイラとプラグインを提供しています。これらの言語は、NEO仮想マシンがサポートする命令セットに高度な言語をコンパイルするために使用されます。最初のコンパイラはMSIL（Microsoft中間言語）用ですので、理論的には.Net言語とMSILに変換できる言語はすべてすぐにサポートされます。

現在サポートされている言語は次のとおりです:

1) C＃、VB.Net、F＃
2) Java、Kotlin

サポートする予定の言語は次のとおりです：

1) C、C ++、GO
2) Python、JavaScript

多言語サポートにより、新しい言語を習得する必要はなく、90％以上の開発者がNEOスマートコントラクトの開発に直接参加することができます。既存のビジネスシステムコードをブロックチェーンに直接移植することさえできます。これにより、将来のブロックチェーンの全体的な人気が大幅に向上すると考えています。

さらに、伝統的なスマートコントラクトは、ツールサポートが不足しているため、デバッグやテストが困難です。ただし、NEOはNEO仮想マシンレベルでのデバッグをサポートしているため、NEO Smart Contract 2.0の開発をより簡単かつ迅速に行うことができます。

## スマートコントラクトの開始

スマートコントラクトを開始するには2つの方法があります：

1. コントラクトユーザー認証： スマートコントラクトはコントラクトアカウントであり、ユーザーがアセット内でコントラクトアカウントを使用するように要求すると、スマートコントラクトが開始されます。
2. 手動でトランザクションコールを送信するスマートコントラクト： ここで、スマートコントラクトの実装を開始するトランザクション（呼び出しトランザクション）を送信します。

## NeoVM （NEO仮想マシン）

NeoVMは、NEOスマートコントラクトコードを実行する仮想マシンです。 オペレーティングシステム、またはVmwareやHyper-VなどのOSをシミュレーションするプログラムのようなものではなく、狭義の仮想マシンのコンセプトを意味します。

たとえば、Java JVMまたは.Net CLRでは、ソースコードがバイトコードにコンパイルされ、対応する仮想マシン上で実行されます。 JVMまたはCLRは、実際の物理マシン上で命令を実行するのと同様のバイトコードを実行します。 特に、対応するバイナリ命令はそのまま物理マシン上で実行します。 物理マシンは、メモリから命令を取り出し、バス（Bus）を介してCPUに転送し、結果をデコード、実行、格納します。

### 仮想マシンアーキテクチャ

   ![](C:/neo-project/docfx/docs/ja-jp/sc/assets/neo-vm.jpg)

上記の図は、Neo仮想マシン（NeoVM）のシステムアーキテクチャ図です。破線ボックスの内側は仮想マシンのコアです。

#### 実行エンジン

左側の緑エリアは、相互運用可能なサービスレイヤー（後述）で、フロー制御、スタック操作、ビット操作、算術演算、論理演算、暗号化などの一般的な命令を実行できる仮想マシン実行エンジン（CPUに相当）です。

#### 計算スタック

グレーの中間部分は仮想マシンの計算スタック（メモリに相当）であり、今日の仮想マシンには、独自の長所と短所を持ち、またそれぞれに象徴的な特徴のある、スタックベースとレジスタベースの2つの実装があります。 JVM、CPython、および.Net CLRはスタックベースの仮想マシンであり、DalvikやLua5.0などのレジスタベースの仮想マシンも存在します。 スタックベースの仮想マシンには、実際の操作を実行するときに仮想マシンがスタックと直接対話できるコンセプトを持ちます。

デフォルトでは、オペランドスタックからデータをフェッチするため、オペランドを指定する必要はありません。 たとえば、x86アセンブリの "ADD EAX, EBX"は実装の中に、どこから操作を行う必要があるか、また、その結果をどこに格納するかを指定する必要があります。 しかし、スタックベースの仮想マシン命令では、これらのパラメータを指定する必要はありません。 たとえば、単純な演算を追加するために、デフォルトのオペランドがオペランドスタックに格納されます。スタックから2つのデータを直接ポップして加算することができます。

#### 相互運用可能なサービスレイヤー

右側の青い部分は、仮想マシンの相互運用可能なサービスレイヤー（周辺機器と同等）です。 現在、相互運用可能なサービスレイヤーは、ブロック情報、取引情報、契約情報、資産情報などにアクセスできるスマートコントラクトのチェーンデータにアクセスするためのいくつかのAPIを提供しています。

さらに、相互運用可能なサービスレイヤーは、各コントラクトに永続的な記憶領域を提供します。 それぞれのスマートコントラクトは、オプションとして、永続ストアのコンテキストではなく、契約先の呼び出し先によって決定されるkey-valueオブジェクト形式のプライベートストレージを使用して作成されます。 もちろん、呼び出し元は、呼び出し元に独自の記憶域コンテキストを渡す必要があります（承認を完了するため）、呼び出し元は読み取りと書き込み操作を実行できます。

### チャージモード

スマートコントラクトは、導入コストと実行コストに分けられた一定の料金を請求するようにプログラムすることができます。

導入コストとは、開発者がブロックチェーンにスマートコントラクトをデプロイするために、ブロックチェーンシステムに支払う必要のある料金を指します（現在500GAS）。 実行コストは、ユーザーごとがスマートコントラクトの実行のための料金（現在は無料）を支払います。

## 単純なスマートコントラクト

ここでは、`VerificationCode`を継承したシンプルなスマートコントラクトの例をを示します。

```c#
public static bool Verify ()
{
    Return true;
}
```

ここでは、コントラクトの戻り値は常に`true`であり、誰でもアセットのコントラクトアドレスを使うことができることを示しています。（お金の支払いに例えることできます）

NEOクライアントウォレットには資産を削除する機能があります。 アセットを削除すると、アセットは指定されたアドレスに送信されます。これは上記スマートコントラクトによって生成されたコントラクアドレスであり、誰でもアドレスを使用できます。

```c#
public static bool Verify ()
{
    Return false
}
```

コントラクトの戻り値は常に`false`であり、このコントラクトの資産は、会社が株式の一部を保管することができるように、使用不能（資産の焼却または破壊に例えることできます）であることを示しています。

その他の例については、以下を参照してください:

[Hello World](tutorial/HelloWorld.md)

[Lock (ロック・コントラクト)](tutorial/lock.md)

[Domain (ドメインネームシステム)](tutorial/Domain.md)