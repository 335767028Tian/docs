# 네오 스마트 계약 (Smart Contract) 소개

## 스마트 계약이란 무엇인가?
스마트 계약이란 디지털 형식으로 규정된 일련의 약속들로, 계약 당사자들이 어떻게 계약을 이행할 지에 대한 방법까지 포함합니다. 
블록체인 기술을 통해 이루는 탈 중앙화되고, 변경 불가의, 고도로 안정된 매우 유용한 스마트 계약을 활용 할 수 있습니다. 스마트 계약은 
블록체인 기술에 있어서 매우 중요한 요소중의 하나이며, 블록체인이 분열 기술(disruptive technology)이라 불리는 이유입니다. 
현재 날이 갈수록 블록체인 기술의 효율은 높아지고 있습니다.

## 네오 스마트 계약의 특징은?

네오 스마트 계약 2.0은 다음의 특징들을 가지고 있습니다 : 확실성, 높은 성능 그리고 확장성.
네오 계약에는 다음과 같은 형식들이 있습니다 : 
확인 계약(validation contract), 함수 계약(function contract), 그리고 어플리케이션 계약(Application contract)

성능 관점에서 보자면, 네오는 계약 실행 환경으로 가벼운(lightweight) NeoVM (NEO Virtual Machine)을 사용합니다. 
NeoVM은 시작 속도가 빠르고 자원 소모가 적기 때문에 스마트 계약 같은 짧은 과정(short procedures)에 적합합니다. 
정적 편집(Static compilation)과 핫스팟 계약의 임시 저장기능은 JIT(실시간 컴파일러)기술을 이용해 비약적으로 향상될 수 있습니다. NeoVM의 
명령어 부분(instructinal step)에서 스마트 계약에 있어서 암호 알고리즘의 실행 효율을 최적화 하는 일련의 암호화 명령어들이 제공됩니다. 
덧붙여 데이터 조작 설명 부분은 복잡한 데이터의 구조와 배열(array)부분을 직접적으로 지원합니다. 
위에 나열된 모든 특징들이 네오 스마트 계약2.0의 효율을 향상시키는 데 중요한 역할을 합니다

네오 스마트 계약 2.0은 고도의 동시성과 동적 분할성(portioning)의 저-결합(low-coupling) 디자인을 통한 결합구조로 인해 
확장성있는 접근법을 지니고 있습니다. 이 저 결합 계약 과정은 가상 머신(NeoVM)에서 실행되며 상호작용(interactive) 서비스 레이어를 통해 
외부와 교신합니다. 그렇기 때문에 그렇기 때문에 대부분의 스마트 계약 기능의 업그레이드는 이 상호작용 서비스 레이어의 API를 통해 이루어집니다.

## 모든 언어로 스마트 계약 작성 가능

프로그래밍 언어 관점에서 보면, 네오 스마트 계약2.0과 이더리움의 차이점은 보다 더 직관적입니다 : 
이더리움의 원 솔리더티(Solidity) 언어와 달리, 네오 스마트 계약은 거의 모든 고급 프로그래밍 언어로 직접 작성이 가능합니다. 
먼저 지원하는 언어는 C#, VB. Net, F#, Java와 Kotlin입니다. 네오는 이 언어들에 대해 컴파일러와 플러그인을 제공하며, 
이들을 통해 네오 가상 머신이 지원하는 명령어들로 컴파일할 수 있습니다. 첫 번째 컴파일러는 MSIL (Microsoft intermediate language)을 
지원하기 때문에 이론상, 어떤 .Net 언어나 다른 언어들도 MSIL로 변환되어 바로 지원됩니다. 

현재 지원하는 언어들은 다음과 같습니다 : 

1) C#, VB.Net, F#
2) Java, Kotlin
3) Python

향후 지원될 언어들은 아래와 같습니다 :

1) C, C ++, GO
2) JavaScript

다양한 언어를 사용할 수 있기 때문에, 90%이상의 개발자들이 새로운 언어를 배울 필요 없이 바로 네오 스마트 계약 개발을 시작할 수 있습니다. 
현존하는 비즈니스 시스템 코드는 블록체인상에 바로 포팅될 수 있습니다. 우리는 네오의 이런 면이 미래 블록체인의 인기를 크게 올릴 것이라고 생각합니다. 

추가적으로, 기존 스마트 계약들은 디버깅이 어렵고 테스트를 위한 툴들이 부족합니다. 그러나 네오는 네오 가상 머신 상에서 디버깅 툴을 제공하기 때문에, 
사용자들이 네오 스마트 계약2.0을 보다 쉽고 빠르게 개발할 수 있습니다. 

## 스마트 계약 발동 조건(triggers)

스마트 계약 발동 조건에는 두 가지가 있습니다 : 

1. 계약 사용자 증명(Authentication) : 스마트 계약이 계약 계좌(contract account)에 있고, 사용자가 자산 상의 계약을 사용하고자 할 경우, 스마트 계약이 발동됩니다.
2. 수동으로 전송을 하고 스마트 계약을 호출 하는 경우 : 사용자가 스마트 계약을 작동시키기 위해 전송(Invocation Transaction)을 하는 경우 스마트 계약이 발동됩니다. 

## 네오 가상 머신 (NeoVM, Neo Virtual Machine)

NeoVM은 네오 스마트 계약을 실행하는 가상 머신입니다. 여기서는 이러한 개념에서 가성 머신을 좁은 의미에서 다룰 것입니다. 일반적으로 말하는 Vmware나 Hypster-V같은 운영 체제나 그에 준하는 프로그램들에 대해서는 다루지 않겠습니다.

예를 들면, 자바에서 쓰는 JVM이나 .NET CLR의 경우 소스코드는 해당되는 바이트코드(bytecode)로 컴파일 된 다음 각기 해당하는 가상 머신에서 실행됩니다. JVM과 CLR은 실제 머신에서 명령어를 수행하는 것과 비슷한 방식으로 바이트코드를 실행합니다. 현저하게 바이너리(binary)명렁어들은 여전히 실제 머신에서 실행됩니다. 실제 머신은 메모리에서 명렁어들을 가지와서 버스를 통해 CPU로 보낸 다음에 디코딩, 실행한 후 결과를 저장합니다.

### 가상 머신 구조(architecture)

   ![](C:/neo-project/docfx/docs/ko-kr/sc/assets/neo-vm.jpg)

위의 그림은 네오 가상 머신의 구조를 보여줍니다. 점선 박스안의 부분이 네오 가상 머신의 코어입니다.

#### 실행 엔진 (Execute engine)

오른 쪽 녹색 부분은 가상 머신의 실행 엔진(실제 머신에서의 CPU와 같은 의미)에 해당하며, 플로우 컨트롤(flow control), 스택 연산(stack operation), 비트 연산(bit operation), 대수 연산, 로직 연산, 암호화 과정과 상호 운영(interoperable) 서비스 레이어(아래 부분에서 설명) 등을 실행합니다. 

#### 스텍 계산

회식 가운데 부분은 가상 머신의 스텍 계산 영역(메모리에 해당)으로 가상 머신은 이 부분에 스텍에 기반을 두는 방법과 레지스터에 기반을 두는 두 가지 방법으로 저장할 수 있으며 두 방법 다 나름의 장/단점이 존재합니다. 스텍에 기반을 둔 가상 머신은 JVM과 CPython, .NET CLR등이 있으며 레지스터에 기반을 둔 VM들은 Dalvik과 Lua 5.0같은 것들이 있습니다. 스텍 기반의 가상 머신들은 실제 연산 시 실제 머신 스텍과 직접 상호작용하는 방식으로 작동합니다. 

디폴트가 데이터를 연산수(operand)스텍에서 가져오기 때문에 별도의 연산수를 지정할 필요가 없습니다. 예를 들면 x86 어셈블리의 경우, “ADD EAX, EBX”의 경우 사용자는 연산이 어디서 시작하는 지, 또 결과가 어디에 저장되어야 하는 지 지정해야 합니다. 그러나 스텍 기반의 가상 머신의 명령어에서는 이런 과정이 필요 없습니다. 예를 들어 간단한 연산을 추가하기 위해 디폴트 연산수가 해당 연산수 스텍에 저장되며, 해당 스텍에서 추가 연산을 위한 두 데이터를 직접적 끄집어 낼 수 있습니다. 

#### 상호 운영 (Interoperable) 서비스 레이어

오른쪽 파란 색 부분은 가상 머신의 상호 운영 서비스 레이어(주변장치(peripheral)에 해당)입니다. 
현재, 이 상호 운영 서비스 레이어는 스마트 계약의 체인-체인 데이터에 접근하기 위한 API들을 제공하는데, 이 API들은 블록 정보, 전송 정보, 연력처, 자산 정보 등에 접근 할 수 있습니다. 

추가적으로 이 상호 운영 사비스 레이어는 각각의 계약에 대해 지속적인(persistent) 저장장소를 제공합니다.
각 스마트 계약은 선택적으로 개인 저장소(private storage)를 생성하는데, 이는 영구 저장소의 컨텍스트(context)안이 아니라, 해당 계약 호출받는 쪽 의해 결정되는 키 밸류 오브젝트의 형태(form) 안에 존재합니다. 물론 호출하는 쪽에서 그쪽의 저장 컨텍스트를 호출되는 쪽에 전해줄 수 있고(인증을 완료하기 위해) 호출하는 쪽에서 읽고 쓰는 연산을 수행할 수 있습니다.

### 부과 모드 (Charge mode)

스마트 계약은 특정 비용을 전개(deployment) 비용과 실행(implementation) 비용으로 나누어  부과할 수 있게 프로그램될 수 있습니다. 

전개 비용은 개발자가 스마트 계약을 블록체인상에 전개할 때 지불하는 비용입니다. (현재 500GAS), 사용자는 스마트 계약을 실행할 때 필요한 실행 비용을 지불할 수 있습니다. (현재는 무료)

## 간단한 스마트 계약

아래는 입증 코드에서 상속되는 스마트 계약입니다.

```c#
public static bool Verify ()
{
Return true;
}
```

위 계약의 리턴 값은 항상 참이며, 누구든 이 연락처 주소에 있는 자산을 사용할 수 있음을 의미합니다. (‘돈’으로 이해될 수 있음)

클라이언트의 전자지갑 내 자산을 삭제할 수 있는 함수가 있습니다. 사용자가 자산을 삭제 시, 해당 자산은 특정주소로 이전되며, 이 주소는 위의 스마트 계약에 의해 생성됩니다. 

```c#
public static bool Verify ()
{
Return false
}
```

위 스마트 계약의 리턴 값은 항상 거짓입니다. 이는 해당 계약의 자산이 사용될 수 없음을 의미합니다. (자산의 파기) 이는 마치 취소된 회사의 지분과 같습니다. 

아래에 더 많은 예제들이 있습니다 : 

[Hello World](tutorial/HelloWorld.md)

[Lock (lock)](tutorial/lock.md)

[Domain (Domain Name System)](tutorial/Domain.md)